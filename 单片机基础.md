单片机组成原理--期末复习

以Intel早期推出的MCS-51系列为例，此笔记使用80C51

### 第一章 单片机基础知识概述

#### 1.1 单片机的概念 

单片机SCM,Small-Chip-Microcomputer.是一种[集成电路芯片]()，继承了CPU , 存储器 ，IO, 定时器/计数器，串行口，中断系统等构成的完整微型计算机。

#### 1.2 单片机的特点

体积小，[可靠性高]()，性价比高

低功耗，低电压

易拓展

#### 1.3 51单片机介绍

| 片内rom | 片内ram | 定时/计数器 | 并行口 | 串行口 | 中断源 |
| ------- | ------- | ----------- | ------ | ------ | ------ |
| 4k      | 128+128 | 2           | 4      | 1      | 5      |

> ### 注：
>
> ### 并行口（Parallel Port）
>
> #### 特点：
>
> 1. **多线传输**：并行口使用多条线路同时传输多个比特的数据，通常是一字节（8位）或更多。
> 2. **高传输速率**：由于多条线路同时传输数据，理论上传输速率较高。
> 3. **适用短距离**：因为每条线上的信号可能会出现时序误差，传输距离较短（通常在几米范围内）。
> 4. **较宽的连接器**：并行口连接器一般较宽，因为需要多个引脚对应多个数据线。
>
> ### 串行口（Serial Port）
>
> #### 特点：
>
> 1. **单线传输**：串行口使用一对传输线（一般是一个用于发送数据，一个用于接收数据）依次传输每一比特的数据。
> 2. **低传输速率（相对并行口）**：由于是逐比特传输，理论上传输速率较并行口低。
> 3. **适用长距离**：因为只有一对信号线，同步问题较少，可以支持较长距离的数据传输（几百米甚至更多）。
> 4. **较窄的连接器**：串行口连接器一般较窄，通常是9针或25针的D型接口。
>
> ### 总结
>
> 并行口和串行口各有优劣，选择使用哪种接口主要取决于具体应用需求。在现代计算机和电子设备中，串行接口（如USB、SATA、UART等）因其简单可靠、适用范围广泛，逐渐成为主流，而传统的并行口应用逐渐减少。



### 题目

下列单片机型号中不属于51系列的是 

A, AT89S52	B. 78C52	C. AT90S1200	D. STC15W201S

C. AT90S1200 不是

### 第二章 单片机的结构

#### 2.1 8051的内部结构

1个中央处理器(CPU)

2个16位定时/计数器

1个全双工串口

4个双向并行io，并口

5个中断源

1个时钟



> ### 全双工（Full Duplex）
>
> #### 特点：
>
> 1. **双向同时传输**：全双工通信允许数据在两个方向上同时传输。这意味着发送和接收可以同时进行，不会互相干扰。
> 2. **效率高**：由于可以同时发送和接收数据，全双工通信的效率高于半双工。
> 3. **硬件支持**：需要硬件支持双向同时通信，通常有独立的发送和接收通道。
>
> ### 半双工（Half Duplex）
>
> #### 特点：
>
> 1. **双向但非同时传输**：半双工通信允许数据在两个方向上传输，但不能同时进行。一个方向在传输时，另一个方向必须等待。
> 2. **效率较低**：由于不能同时进行数据传输，半双工通信的效率较低。
> 3. **硬件简单**：硬件实现相对简单，因为只需要一个通道在不同时间进行发送和接收。



#### 2.1.2 关于cpu运算器中的PSW，程序状态寄存器

PSW是一个8位状态专用寄存器，这里主要关注CY(位7) 进位标志位，当最高位进位，系统自动置1。

OV(位2) : 溢出标志位，系统自动置1。OV 可由异或逻辑表达式算出：OV = C6y 异或 C7y

RS1,RS0 用来选择工作寄存器组

#### 2.2 8051外部引脚

采用HMOS制造工艺的51单片机一般使用40个引脚的双列直插封装DIP

CHMOS使用44个引脚封装，其中4个引脚悬空

##### 2.2.1 引脚分类

电源和晶振 ——Vcc，Vss，XTAL1,XTAL2

控制引脚 —— PSEN(-), ALE/PROG(-), EA(-)/Vpp, RST/Vpd

并行IO —— P0.0-0.7, P1.0-1.7, P2.0-2.7, P3.0-3.7

##### 2.2.2 电源引脚

Vcc(40) +5V

Vss(20) GROUND

##### 2.2.3 外接晶振

XTAL1(19) XTAL2(18)

##### 2.2.4 控制引脚

RST/Vpd(9) RESET/冗余备用电源

ALE/PROG(30) 地址锁存使能输出/编程脉冲输入输出

PROG(-)仅存在与8071，此处忽略

PSEN(-)(29) 输出访问片外程序存储器读选通信号引脚,用作片外ROM芯片使能信号

EA(-)/Vpp(31) 外部ROM允许访问/备用电源此处忽略

外部ROM允许访问引脚，当EA悬空时，/EA=1，CPU从片内读指令，当PC超出4kb寻址，自动转向片外ROM寻址

当/EA=0，CPU谨防问片外

##### 2.2.5 并行io引脚

p0-p3都可用于通用io

#### 2.3 存储器结构

存储器划分地址有两种结构

普林斯顿，也叫冯诺伊曼，为rom，ram统一编址。cpu可以用相同的指令访问rom，ram

哈佛，rom，ram单独编址，rom，ram可以有相同的地址。该结构用于解决程序运行时的访问瓶颈问题

存储器空间结构

以物理地址看，4个存储空间，片内，片外ram（256b），片内篇外rom

以逻辑看，为3个，片内片外rom统一编制（4k）



> ### 为什么片内RAM和片外RAM不能统一编址
>
> 1. **硬件架构差异**：
>    - 片内RAM和片外RAM连接方式不同。片内RAM直接与处理器内核相连，而片外RAM通过外部总线（如SPI、I2C、并行接口等）相连。
>    - 片外RAM的访问可能需要额外的地址解码和总线控制逻辑，增加了访问延迟和复杂性。
> 2. **地址空间限制**：
>    - 微控制器或处理器的地址空间是有限的。片内RAM通常有固定的地址范围，而片外RAM的地址范围可能通过片选信号（Chip Select）等方式进行解码。
>    - 统一编址会复杂化地址解码逻辑，增加硬件设计的复杂性。
> 3. **性能和效率**：
>    - 片内RAM用于高频访问的数据，统一编址可能导致片内RAM和片外RAM之间的访问混淆，降低系统性能。
>    - 分开编址可以优化内存访问路径，提高系统效率。



#### 2.4 程序存储器 —— ROM

根据/EA的电位，可选片内，片外rom

/EA悬空或/EA=1时，两者都可访问

> `/EA` 是 External Access 的简写

#### 2.5 数据存储器 —— RAM

RAM用于存放中间结果，标志位，待调试的程序。RAM断电即丢失

片外可扩充64kb，这里只看片内

##### 2.5.1 片内ram结构

分为低128b，高128b。低128为普通RAM，高128b为SFR区

低128B为普通RAM，其中00-1FH可作为工作寄存器使用，分为4组，每组8单元，按序命名为R0-R7。

虽然有四组工作寄存器，但CPU同一时间只能使用一组，根据PSW中的RS1和RS0标志设置

20H-2FH为位寻址区，30H-7FH为用户RAM区

在高128B中共21个SFR，特殊功能寄存器是为了未来功能增加预留的空间，对其读/写是没有意义的

#### 2.6 单片机复位时各寄存器状态

| A    | B    | PSW  | P0-P3 | IP   | IE   | TCON,TMOD | SCON,SBUF | TL1,TH1 | PCON |
| ---- | ---- | ---- | ----- | ---- | ---- | --------- | --------- | ------- | ---- |
| 00H  | 00H  | 00H  | FFH   | 0B   | 0B   | 00H       | 00H       | 00H     | 0B   |

堆栈指针SP指向 81H

##### 2.6.1 单片机复位条件

RST 满足复位条件的高电平



> ### 寄存器（Register）
>
> #### 特点：
>
> 1. **高速**：寄存器是CPU内部的高速存储单元，通常是处理器速度最快的存储器。
> 2. **小容量**：寄存器数量有限，容量较小，通常在几十到几百字节之间。
> 3. **特殊用途**：寄存器专门用于临时存储处理器正在执行的指令和数据，如操作数、中间结果、地址等。
> 4. **直接访问**：寄存器是CPU直接访问和操作的存储单元，访问时间极短（通常是一个时钟周期）。
> 5. **分类**：根据功能不同，寄存器可以分为通用寄存器、专用寄存器（如程序计数器、指令寄存器）和状态寄存器等。



> ### 地址锁存使能输出（ALE）的功能和用途
>
> #### 多路复用地址和数据总线
>
> 一些处理器和微控制器（如早期的Intel 8085和8051系列）使用同一组引脚来传输地址和数据。为了有效地分离地址信息和数据信息，需要一个控制信号来指示当前总线上传输的是地址还是数据，这就是ALE信号的作用。
>
> ### 例子：Intel 8051 微控制器
>
> 在Intel 8051微控制器中，ALE信号是一个重要的控制信号，用于将地址和数据分离。
>
> - **地址锁存**：在机器周期的前半部分，ALE信号高，低8位地址通过P0口输出，并锁存在外部锁存器中。
> - **数据传输**：在机器周期的后半部分，ALE信号低，P0口用于传输数据。



> ### PSEN(-)
>
> ### 详细解释
>
> #### 作用
>
> 当微控制器需要从外部程序存储器读取数据时，它会激活这个选通信号。外部存储器检测到这个信号后，将相应的存储数据发送到数据总线供微控制器读取。



> ### 锁存（Latching）
>
> 是一种用于存储和保持数据信号状态的电路技术。锁存器（Latch）是这种技术的实现电路，通常用于在时钟信号的控制下捕获和保持数据信号的状态。锁存器在数字电路和计算机系统中起到重要的作用，尤其是在寄存器、缓冲器、状态保存等场景中。
>
> 锁存器（latch）是一种基本的数字电路元件，用于存储和保持二进制信息。它是构建时序电路和存储单元的基本组件之一。锁存器的主要功能是将输入信号保持在输出端，直到新的输入信号到来，从而稳定输出信号。

​       

> ### 选通信号（Chip Select, CS 或 Chip Enable, CE）
>
> 是一种控制信号，用于选择和启用特定的设备或电路模块，使其能够参与数据传输和处理。在系统中，有多个设备可能共享同一总线，选通信号用于确定哪一个设备处于活动状态，能够接收或发送数据



> #### PSW可能能够被映射到RAM地址空间以便于访问，但这并不意味着PSW同时存在于CPU和RAM中。具体来说：
>
> ### 1. **PSW的物理位置**
>
> PSW实际物理位置是在CPU内部。它是一个专门的寄存器，用于存储处理器状态信息，包括条件标志（如零标志、进位标志）和控制标志（如中断使能标志）。
>
> ### 2. **映射到RAM地址空间**
>
> 在某些计算机体系结构中，PSW可以通过特定的指令集或机制被映射到RAM的地址空间。这种映射的目的是为了方便软件读取或修改PSW的内容。例如，某些特殊指令可以将PSW的内容保存到RAM中的一个特定地址，或从RAM中的一个特定地址加载内容到PSW。
>
> 这种映射机制可以通过以下几种方式实现：
>
> - **特殊指令**：CPU可能有特定的指令，用于将PSW的内容移动到RAM中的特定地址，或从RAM中的特定地址加载内容到PSW。
> - **内存映射寄存器**：在一些嵌入式系统中，特定的硬件寄存器（包括PSW）可以被内存映射，使得它们看起来像RAM地址空间的一部分。
>
> ### 3. **逻辑上的映射，不是物理复制**
>
> 需要明确的是，PSW在RAM中的映射只是逻辑上的，并不是物理上的复制。实际上，PSW仍然驻留在CPU内部的寄存器中，但可以通过某种机制让它的内容在RAM地址空间中被访问到。换句话说，RAM地址空间中的那个位置并不是存储PSW的实际物理位置，而是一个用于访问PSW内容的通道或映射。

### 题目

#### 80C51片内低128BRAM 区按功能可分为哪几个组成部分，各部分主要特点是什么？

分为工作寄存器区，在00H-1FH为工作寄存器区，该区被分为4组，每组有8个单元，名为R0-R7。

20H-2FH为位寻址区，30H-7FH为用户RAM

### 第四章 单片机通用IO(并行口)

> 该章节为实验章节

#### 4.1.1 发光二极管

发光二极管是最基础的输出设备。有高，低电平驱动两种模式

由于低电平驱动时能提供较大电流，该章节实验使用低电平驱动。

> 低电平驱动时单片机能够提供较大电流，主要是由于内部的NPN晶体管或NMOS晶体管在导通时具有较低的导通电阻。这种设计使得在低电平驱动时能够承受较大的电流，而高电平驱动时由于PNP晶体管或PMOS晶体管的导通电阻较大，能够提供的电流相对较小。

由此，IO输出0时LED点亮，输出1时LED熄灭。

#### 4.1.2 按键和开关

按键和开关是最基础的输入设备，和IO直接相连，当按键或开关闭合时，IO口电平会反转，cpu通过读电平可以识别特定按键

关于上拉电阻，按键与开关松开时的向io输出高电平是因为上拉电阻供电，但P0口是漏极开路，如果不设置上拉电阻开关松开时状态不确定。p1-p3内部预设上拉电阻，按键开关有没有上拉电阻无所谓。

#### 实验一 独立按键识别

根据按键开启不同LED，要求按键释放后LED保持状态

设计思路：通用IO，也就是并行口，P0口有8个引脚，一共读入8位数据(当然P1-P3也是同理)，读入数据实际上就是施加在P口的电平状态，通过按键改变点平状态。再将电平状态通过其他IO输出来控制LED，但输出前需要设置一个变量存储读入的电平。

这里为了方便只接两个灯，将剩余引脚悬空。LED接在P0.0,P0.1,开关接在P1.0,P1.2

代码：

```c
#include<reg51.h>
void main(){
    unsigned char key; //store input flag
    while(1){
        key = P1 & 0x0A;
        P0 = key;
    }
    
}
```

复盘：8051最终控制的只是电平状态而已，所以对应的引脚一定要接对应的元件

#### 实验二  延时流水灯

设计代码，演示led流水灯效果

设计思路：流水灯在不同灯之间切换时需要设置延时，否则电平状态切换太快难以观察到现象。延时函数不需要太精确，用内部晶振就可以。在相等的时间间隔后切换电平状态，以实现流水灯效果。切换电平状态需要提前存储好不同电平模式，用循环控制即可。

电平模式：fe，fd，fb，ef

代码：

```c
#include<reg51.h>
unsigned char led[] = {0xfe,0xfd,0xfb,0xef};
void halWait(unsigned char time){
    unsigned int j=15000;
    for(;time>0l;time--){
        for(;j>0;j--){
        }
    }
}
void main(){
	while(1){
        unsigned int i =0;
        for(;i<4;i++){
            P0=led[i];
            halWait(1000);
        }
    }
}
```

#### 实验三 条件传输控制方式——led花样闪烁

利用51单片机内部并行口，分别接开关和发光二极管，采用有条件传输控制方式，实现开关控制发光二极管的亮灭。设置总开关，当总开关闭合时，分开关可以控制发光二极管，否则不能。

设计思路：看似复杂，其实核心就是监视某一位电平状态，若该电平符合要求，就把读入的电平送输出。

其实硬件设置开关直接短路就行

代码：

```c
#include<reg51.h>
sbit p1_3 = P1^3;//DEFINE MAIN SWITCH
void main(){
    while(1){
        if(P1_3 == 1){
            P0 = P1;
        }
    }
    
}
```

> 在 Keil C 编程中，定义单个位变量时，通常使用 `sbit` 关键字。为了指定某个位在某个端口上的位置，Keil C 语法要求使用下划线 `_` 来表示位和端口号之间的关系，而不是使用点 `.`。这是因为点号通常用于表示结构体成员的访问，而不是位操作。`P1^3` 表示访问端口 P1 的第 3 位。这里的 `P1` 是一个特殊功能寄存器（SFR），`^` 符号用于表示这个寄存器的特定位。

#### 4.1.3 数码管

LED数码管具有显示亮度高，响应速度快的特点，一般用7段数码管。内部由7个发光条形二极管和一个小圆点发光二极管组成。有共阴，共阳两种

显示字符需要用段码表，常用段码如下：

|      | 共阴 | 共阳 |
| ---- | ---- | ---- |
| 0    | 3FH  | C0H  |
| 1    | 06H  | F9H  |
| 2    | 5BH  | A4H  |
| 3    | 4FH  | B0H  |
| 4    | 66H  | 99H  |

####  实验四 数码管静态闪烁

设计思路：没什么可说的，字模提前存好，按时间显示即可

代码：

```c
#include<reg51.h>
unsigned char led_mode[] = {0x3f,0x06,0x5b,0x4f,0x66};
void halWait(unsigned char time){
    unsigned int j=15000;
    for(;time>0l;time--){
        for(;j>0;j--){
        }
    }
}
void main(){
    while(1){
        unsigned int j=0;
        for(;j<4;j++){
            P2 = led_mode[j];
            halWait(1000);
        }
        
    }
    
}
```

复盘：没啥可说的，就是控制电平

#### 实验五 数码管拆分显示

设计思路：设置两个数码管，分别显示十位和个位，提前设置好0-9的字模，设置count，count为两位，取余的个位，数除得十位

代码：

```c
#inlcude <reg51.h>
unsigned char led_mode[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};
void halWait(unsigned int time){
unsigned int j=15000;
    for(;time>0l;time--){
        for(;j>0;j--){
        }
    }
}

void main(){
    unsigned int count=0;
    for(;count < 100; count++){
        P0 = led_mode[count%10];
        P2 = led_mode[count/10];
        halWait(1000);
    }
}
```

实验六 数码管动态闪烁

静态显示是一个并行口接一个数码管，但该方法占用资源太多了，每个并行口都要接一个数码管，这简直在胡闹

而动态闪烁则将多个数码管中相同段码引脚并连接在一个8位并行口上而每个数码管的位码引脚，也就是公共端分别有一根io线控制，类似于片选，通过控制公共端来控制数码管亮灭。但这种方法只能动态显示多位数字，因为段码都接的相同电平，所以利用数码管快速开关来形成时间差，利用人眼暂留来实现某一位数字的刷新

如何实现快速刷新，halwait设短就行

代码 ：

```c
#include <reg51.h>
unsigned char led_mode[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};
void halWait(unsigned int time){
unsigned int j=15000;
    for(;time>0l;time--){
        for(;j>0;j--){
        }
    }
}
void main(){
    unsigned char led_pointer=0;
    while(1){
        unsigned int j=0;
       
            P3 = 2-led_pointer;
            P2 = led_mode[led_pointer];
        	led_pointer = 1-led_pointer;
        	haiWait(10);
        
    }
    
}

```
### Waiting For Updating ###
